#define DEBUG_TYPE "testpass"

#include "llvm/Pass.h"
//#include "llvm/PassManager.h"
#include "llvm/Analysis/Passes.h"
#include "llvm/Transforms/IPO/PassManagerBuilder.h"
#include "llvm/Transforms/Utils/BasicBlockUtils.h"
#include "llvm/ADT/None.h"
#include "llvm/ADT/SmallVector.h"
//#include "llvm/IR/InstVisitor.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/LegacyPassManager.h"
#include "llvm/IR/Type.h"
#include "llvm/IR/Use.h"
#include "llvm/IR/User.h"
#include "llvm/IR/Value.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Constants.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/InitializePasses.h"

using namespace llvm;

namespace llvm {
  ModulePass *createSecretProtectionPass();
  void initializeSecretProtectionPassPass(PassRegistry&);

  class SecretProtectionPass : public ModulePass {

  public:
    static char ID;

    SecretProtectionPass() : ModulePass(ID) {
      initializeSecretProtectionPassPass(*PassRegistry::getPassRegistry());
    };

    bool runOnModule(Module &M) override;
    void getAnalysisUsage(AnalysisUsage &AU) const override;
  };
}

char SecretProtectionPass::ID = 0;

ModulePass *llvm::createSecretProtectionPass() {
  return new SecretProtectionPass();
}

static void addSecretProtectionPass(const PassManagerBuilder &builder,
			      legacy::PassManagerBase &PM) {
  PM.add(new SecretProtectionPass());
}

static RegisterStandardPasses s(PassManagerBuilder::EP_OptimizerLast,
                addSecretProtectionPass);

INITIALIZE_PASS(SecretProtectionPass, "secret-protect", "SecretProtection Pass", false, false)

bool SecretProtectionPass::runOnModule(Module &M) {
  for (GlobalVariable &GV : M.globals()) {
    if (!GV.getName().equals("in_key"))
      continue;
    for (User *U : GV.users()) {
        U->dump();
      for (User *U2 : U->users()) {
        U2->dump();
        for (User *U3 : U2->users()) {
          if (LoadInst *LI = dyn_cast<LoadInst>(U3)) {
            IRBuilder<> Builder(LI);
            Builder.Create
          }
        }
      }
    }
    dbgs() << "YaTA\n";
  }
  return true;
}

void SecretProtectionPass::getAnalysisUsage(AnalysisUsage &AU) const {
  AU.setPreservesCFG();
}
