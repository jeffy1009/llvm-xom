#include "ARM.h"
#include "ARMSubtarget.h"
#include "llvm/ADT/DenseMap.h"
#include "llvm/CodeGen/MachineBasicBlock.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineFunctionPass.h"
#include "llvm/CodeGen/MachineModuleInfo.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"

using namespace llvm;

#define DEBUG_TYPE "arm-testpass"

namespace llvm {
void initializeARMSecretProtectionPass(PassRegistry &);
}

#define ARM_TESTPASS_NAME "ARM secret protection"

namespace {
  struct ARMSecretProtection : public MachineFunctionPass{
    static char ID;
    ARMSecretProtection() : MachineFunctionPass(ID) {
      initializeARMSecretProtectionPass(*PassRegistry::getPassRegistry());
    }

    const TargetInstrInfo *TII;
    const ARMSubtarget *STI;
    MachineRegisterInfo *MRI;

    bool runOnMachineFunction(MachineFunction &Fn) override;

    StringRef getPassName() const override {
      return ARM_TESTPASS_NAME;
    }

  };
  char ARMSecretProtection::ID = 0;
}

INITIALIZE_PASS(ARMSecretProtection, "arm-secret-protect", ARM_TESTPASS_NAME, false, false)

bool ARMSecretProtection::runOnMachineFunction(MachineFunction &Fn) {
  STI = &static_cast<const ARMSubtarget &>(Fn.getSubtarget());
  TII = STI->getInstrInfo();
  MRI = &Fn.getRegInfo();

  bool Modified = false;

  for (MachineBasicBlock &MFI : Fn) {
    MachineBasicBlock::iterator MBBI = MFI.begin(), MBBIE = MFI.end();
    while (MBBI != MBBIE) {
      MachineBasicBlock::iterator NMBBI = std::next(MBBI);
      MBBI = NMBBI;
      MachineInstr &MI = *MBBI;
      if (MI.getOpcode()!=ARM::t2LDRT)
        continue;
    }
  }

  return Modified;
}

FunctionPass *llvm::createARMSecretProtectionPass() {
  return new ARMSecretProtection();
}
